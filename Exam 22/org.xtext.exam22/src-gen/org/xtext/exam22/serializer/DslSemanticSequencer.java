/*
 * generated by Xtext 2.29.0
 */
package org.xtext.exam22.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.exam22.dsl.Announce;
import org.xtext.exam22.dsl.BoolConstant;
import org.xtext.exam22.dsl.Compare;
import org.xtext.exam22.dsl.Concat;
import org.xtext.exam22.dsl.DslPackage;
import org.xtext.exam22.dsl.End;
import org.xtext.exam22.dsl.EndingTarget;
import org.xtext.exam22.dsl.Equal;
import org.xtext.exam22.dsl.FuncCall;
import org.xtext.exam22.dsl.Function;
import org.xtext.exam22.dsl.IntConstant;
import org.xtext.exam22.dsl.Model;
import org.xtext.exam22.dsl.MultDiv;
import org.xtext.exam22.dsl.Not;
import org.xtext.exam22.dsl.Parenthesis;
import org.xtext.exam22.dsl.PlusMinus;
import org.xtext.exam22.dsl.Question;
import org.xtext.exam22.dsl.Scenario;
import org.xtext.exam22.dsl.StringConstant;
import org.xtext.exam22.dsl.Target;
import org.xtext.exam22.dsl.This;
import org.xtext.exam22.dsl.TypeConstant;
import org.xtext.exam22.dsl.VarRef;
import org.xtext.exam22.dsl.VariableDef;
import org.xtext.exam22.services.DslGrammarAccess;

@SuppressWarnings("all")
public class DslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DslPackage.ANNOUNCE:
				sequence_Announce(context, (Announce) semanticObject); 
				return; 
			case DslPackage.BOOL_CONSTANT:
				sequence_Primitive(context, (BoolConstant) semanticObject); 
				return; 
			case DslPackage.BOOLEAN:
				sequence_Boolean(context, (org.xtext.exam22.dsl.Boolean) semanticObject); 
				return; 
			case DslPackage.COMPARE:
				sequence_Compare(context, (Compare) semanticObject); 
				return; 
			case DslPackage.CONCAT:
				sequence_Concat(context, (Concat) semanticObject); 
				return; 
			case DslPackage.END:
				sequence_End(context, (End) semanticObject); 
				return; 
			case DslPackage.ENDING_TARGET:
				sequence_EndingTarget(context, (EndingTarget) semanticObject); 
				return; 
			case DslPackage.EQUAL:
				sequence_Equal(context, (Equal) semanticObject); 
				return; 
			case DslPackage.FUNC_CALL:
				sequence_Primitive(context, (FuncCall) semanticObject); 
				return; 
			case DslPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case DslPackage.INT_CONSTANT:
				sequence_Primitive(context, (IntConstant) semanticObject); 
				return; 
			case DslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case DslPackage.MULT_DIV:
				sequence_MultDiv(context, (MultDiv) semanticObject); 
				return; 
			case DslPackage.NOT:
				sequence_Primitive(context, (Not) semanticObject); 
				return; 
			case DslPackage.PARAMETER:
				sequence_Parameter(context, (org.xtext.exam22.dsl.Parameter) semanticObject); 
				return; 
			case DslPackage.PARENTHESIS:
				sequence_Primitive(context, (Parenthesis) semanticObject); 
				return; 
			case DslPackage.PLUS_MINUS:
				sequence_PlusMinus(context, (PlusMinus) semanticObject); 
				return; 
			case DslPackage.QUESTION:
				sequence_Question(context, (Question) semanticObject); 
				return; 
			case DslPackage.SCENARIO:
				sequence_Scenario(context, (Scenario) semanticObject); 
				return; 
			case DslPackage.STRING_CONSTANT:
				sequence_Primitive(context, (StringConstant) semanticObject); 
				return; 
			case DslPackage.TARGET:
				sequence_Target(context, (Target) semanticObject); 
				return; 
			case DslPackage.THIS:
				sequence_Primitive(context, (This) semanticObject); 
				return; 
			case DslPackage.TYPE_CONSTANT:
				sequence_Primitive(context, (TypeConstant) semanticObject); 
				return; 
			case DslPackage.VAR_REF:
				sequence_Primitive(context, (VarRef) semanticObject); 
				return; 
			case DslPackage.VARIABLE_DEF:
				sequence_VariableDef(context, (VariableDef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Announce
	 *     Announce returns Announce
	 *     CrossRef returns Announce
	 *
	 * Constraint:
	 *     (name=ID expression=Exp targets+=Target+)
	 * </pre>
	 */
	protected void sequence_Announce(ISerializationContext context, Announce semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Boolean
	 *     Boolean returns Boolean
	 *     Boolean.Boolean_1_0 returns Boolean
	 *
	 * Constraint:
	 *     (left=Boolean_Boolean_1_0 (op='&&' | op='||') right=Equal)
	 * </pre>
	 */
	protected void sequence_Boolean(ISerializationContext context, org.xtext.exam22.dsl.Boolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Compare
	 *     Boolean returns Compare
	 *     Boolean.Boolean_1_0 returns Compare
	 *     Equal returns Compare
	 *     Equal.Equal_1_0 returns Compare
	 *     Compare returns Compare
	 *     Compare.Compare_1_0 returns Compare
	 *
	 * Constraint:
	 *     (left=Compare_Compare_1_0 (op='&lt;' | op='&gt;' | op='&lt;=' | op='&gt;=') right=Concat)
	 * </pre>
	 */
	protected void sequence_Compare(ISerializationContext context, Compare semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Concat
	 *     Boolean returns Concat
	 *     Boolean.Boolean_1_0 returns Concat
	 *     Equal returns Concat
	 *     Equal.Equal_1_0 returns Concat
	 *     Compare returns Concat
	 *     Compare.Compare_1_0 returns Concat
	 *     Concat returns Concat
	 *     Concat.Concat_1_0 returns Concat
	 *
	 * Constraint:
	 *     (left=Concat_Concat_1_0 right=PlusMinus)
	 * </pre>
	 */
	protected void sequence_Concat(ISerializationContext context, Concat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.CONCAT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.CONCAT__LEFT));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.CONCAT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.CONCAT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConcatAccess().getConcatLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConcatAccess().getRightPlusMinusParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns End
	 *     End returns End
	 *     CrossRef returns End
	 *
	 * Constraint:
	 *     (name=ID expression=Exp?)
	 * </pre>
	 */
	protected void sequence_End(ISerializationContext context, End semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EndingTarget returns EndingTarget
	 *
	 * Constraint:
	 *     (end=[End|ID] target=Target)
	 * </pre>
	 */
	protected void sequence_EndingTarget(ISerializationContext context, EndingTarget semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.ENDING_TARGET__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.ENDING_TARGET__END));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.ENDING_TARGET__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.ENDING_TARGET__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEndingTargetAccess().getEndEndIDTerminalRuleCall_1_0_1(), semanticObject.eGet(DslPackage.Literals.ENDING_TARGET__END, false));
		feeder.accept(grammarAccess.getEndingTargetAccess().getTargetTargetParserRuleCall_2_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Equal
	 *     Boolean returns Equal
	 *     Boolean.Boolean_1_0 returns Equal
	 *     Equal returns Equal
	 *     Equal.Equal_1_0 returns Equal
	 *
	 * Constraint:
	 *     (left=Equal_Equal_1_0 (op='==' | op='!=') right=Compare)
	 * </pre>
	 */
	protected void sequence_Equal(ISerializationContext context, Equal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Function returns Function
	 *     CrossRef returns Function
	 *
	 * Constraint:
	 *     (name=ID (types+=Type types+=Type*)? returnType=Type)
	 * </pre>
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=ID functions+=Function* scenarios+=Scenario*)
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns MultDiv
	 *     Boolean returns MultDiv
	 *     Boolean.Boolean_1_0 returns MultDiv
	 *     Equal returns MultDiv
	 *     Equal.Equal_1_0 returns MultDiv
	 *     Compare returns MultDiv
	 *     Compare.Compare_1_0 returns MultDiv
	 *     Concat returns MultDiv
	 *     Concat.Concat_1_0 returns MultDiv
	 *     PlusMinus returns MultDiv
	 *     PlusMinus.PlusMinus_1_0 returns MultDiv
	 *     MultDiv returns MultDiv
	 *     MultDiv.MultDiv_1_0 returns MultDiv
	 *
	 * Constraint:
	 *     (left=MultDiv_MultDiv_1_0 (op='*' | op='/') right=Primitive)
	 * </pre>
	 */
	protected void sequence_MultDiv(ISerializationContext context, MultDiv semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *     CrossRef returns Parameter
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, org.xtext.exam22.dsl.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.CROSS_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.CROSS_REF__NAME));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.PARAMETER__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns PlusMinus
	 *     Boolean returns PlusMinus
	 *     Boolean.Boolean_1_0 returns PlusMinus
	 *     Equal returns PlusMinus
	 *     Equal.Equal_1_0 returns PlusMinus
	 *     Compare returns PlusMinus
	 *     Compare.Compare_1_0 returns PlusMinus
	 *     Concat returns PlusMinus
	 *     Concat.Concat_1_0 returns PlusMinus
	 *     PlusMinus returns PlusMinus
	 *     PlusMinus.PlusMinus_1_0 returns PlusMinus
	 *
	 * Constraint:
	 *     (left=PlusMinus_PlusMinus_1_0 (op='+' | op='-') right=MultDiv)
	 * </pre>
	 */
	protected void sequence_PlusMinus(ISerializationContext context, PlusMinus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns BoolConstant
	 *     Boolean returns BoolConstant
	 *     Boolean.Boolean_1_0 returns BoolConstant
	 *     Equal returns BoolConstant
	 *     Equal.Equal_1_0 returns BoolConstant
	 *     Compare returns BoolConstant
	 *     Compare.Compare_1_0 returns BoolConstant
	 *     Concat returns BoolConstant
	 *     Concat.Concat_1_0 returns BoolConstant
	 *     PlusMinus returns BoolConstant
	 *     PlusMinus.PlusMinus_1_0 returns BoolConstant
	 *     MultDiv returns BoolConstant
	 *     MultDiv.MultDiv_1_0 returns BoolConstant
	 *     Primitive returns BoolConstant
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns FuncCall
	 *     Boolean returns FuncCall
	 *     Boolean.Boolean_1_0 returns FuncCall
	 *     Equal returns FuncCall
	 *     Equal.Equal_1_0 returns FuncCall
	 *     Compare returns FuncCall
	 *     Compare.Compare_1_0 returns FuncCall
	 *     Concat returns FuncCall
	 *     Concat.Concat_1_0 returns FuncCall
	 *     PlusMinus returns FuncCall
	 *     PlusMinus.PlusMinus_1_0 returns FuncCall
	 *     MultDiv returns FuncCall
	 *     MultDiv.MultDiv_1_0 returns FuncCall
	 *     Primitive returns FuncCall
	 *
	 * Constraint:
	 *     (ref=[Function|ID] (expressions+=Exp expressions+=Exp*)?)
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, FuncCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns IntConstant
	 *     Boolean returns IntConstant
	 *     Boolean.Boolean_1_0 returns IntConstant
	 *     Equal returns IntConstant
	 *     Equal.Equal_1_0 returns IntConstant
	 *     Compare returns IntConstant
	 *     Compare.Compare_1_0 returns IntConstant
	 *     Concat returns IntConstant
	 *     Concat.Concat_1_0 returns IntConstant
	 *     PlusMinus returns IntConstant
	 *     PlusMinus.PlusMinus_1_0 returns IntConstant
	 *     MultDiv returns IntConstant
	 *     MultDiv.MultDiv_1_0 returns IntConstant
	 *     Primitive returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Not
	 *     Boolean returns Not
	 *     Boolean.Boolean_1_0 returns Not
	 *     Equal returns Not
	 *     Equal.Equal_1_0 returns Not
	 *     Compare returns Not
	 *     Compare.Compare_1_0 returns Not
	 *     Concat returns Not
	 *     Concat.Concat_1_0 returns Not
	 *     PlusMinus returns Not
	 *     PlusMinus.PlusMinus_1_0 returns Not
	 *     MultDiv returns Not
	 *     MultDiv.MultDiv_1_0 returns Not
	 *     Primitive returns Not
	 *
	 * Constraint:
	 *     exp=Primitive
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.NOT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.NOT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveAccess().getExpPrimitiveParserRuleCall_3_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Parenthesis
	 *     Boolean returns Parenthesis
	 *     Boolean.Boolean_1_0 returns Parenthesis
	 *     Equal returns Parenthesis
	 *     Equal.Equal_1_0 returns Parenthesis
	 *     Compare returns Parenthesis
	 *     Compare.Compare_1_0 returns Parenthesis
	 *     Concat returns Parenthesis
	 *     Concat.Concat_1_0 returns Parenthesis
	 *     PlusMinus returns Parenthesis
	 *     PlusMinus.PlusMinus_1_0 returns Parenthesis
	 *     MultDiv returns Parenthesis
	 *     MultDiv.MultDiv_1_0 returns Parenthesis
	 *     Primitive returns Parenthesis
	 *
	 * Constraint:
	 *     exp=Exp
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, Parenthesis semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.PARENTHESIS__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.PARENTHESIS__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveAccess().getExpExpParserRuleCall_8_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns StringConstant
	 *     Boolean returns StringConstant
	 *     Boolean.Boolean_1_0 returns StringConstant
	 *     Equal returns StringConstant
	 *     Equal.Equal_1_0 returns StringConstant
	 *     Compare returns StringConstant
	 *     Compare.Compare_1_0 returns StringConstant
	 *     Concat returns StringConstant
	 *     Concat.Concat_1_0 returns StringConstant
	 *     PlusMinus returns StringConstant
	 *     PlusMinus.PlusMinus_1_0 returns StringConstant
	 *     MultDiv returns StringConstant
	 *     MultDiv.MultDiv_1_0 returns StringConstant
	 *     Primitive returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveAccess().getValueSTRINGTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns This
	 *     Boolean returns This
	 *     Boolean.Boolean_1_0 returns This
	 *     Equal returns This
	 *     Equal.Equal_1_0 returns This
	 *     Compare returns This
	 *     Compare.Compare_1_0 returns This
	 *     Concat returns This
	 *     Concat.Concat_1_0 returns This
	 *     PlusMinus returns This
	 *     PlusMinus.PlusMinus_1_0 returns This
	 *     MultDiv returns This
	 *     MultDiv.MultDiv_1_0 returns This
	 *     Primitive returns This
	 *
	 * Constraint:
	 *     {This}
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, This semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns TypeConstant
	 *     Boolean returns TypeConstant
	 *     Boolean.Boolean_1_0 returns TypeConstant
	 *     Equal returns TypeConstant
	 *     Equal.Equal_1_0 returns TypeConstant
	 *     Compare returns TypeConstant
	 *     Compare.Compare_1_0 returns TypeConstant
	 *     Concat returns TypeConstant
	 *     Concat.Concat_1_0 returns TypeConstant
	 *     PlusMinus returns TypeConstant
	 *     PlusMinus.PlusMinus_1_0 returns TypeConstant
	 *     MultDiv returns TypeConstant
	 *     MultDiv.MultDiv_1_0 returns TypeConstant
	 *     Primitive returns TypeConstant
	 *
	 * Constraint:
	 *     type=Type
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, TypeConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.TYPE_CONSTANT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.TYPE_CONSTANT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveAccess().getTypeTypeParserRuleCall_4_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns VarRef
	 *     Boolean returns VarRef
	 *     Boolean.Boolean_1_0 returns VarRef
	 *     Equal returns VarRef
	 *     Equal.Equal_1_0 returns VarRef
	 *     Compare returns VarRef
	 *     Compare.Compare_1_0 returns VarRef
	 *     Concat returns VarRef
	 *     Concat.Concat_1_0 returns VarRef
	 *     PlusMinus returns VarRef
	 *     PlusMinus.PlusMinus_1_0 returns VarRef
	 *     MultDiv returns VarRef
	 *     MultDiv.MultDiv_1_0 returns VarRef
	 *     Primitive returns VarRef
	 *
	 * Constraint:
	 *     ref=[CrossRef|ID]
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, VarRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.VAR_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.VAR_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveAccess().getRefCrossRefIDTerminalRuleCall_6_1_0_1(), semanticObject.eGet(DslPackage.Literals.VAR_REF__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Question
	 *     Question returns Question
	 *     CrossRef returns Question
	 *
	 * Constraint:
	 *     (name=ID expression=Exp output=Exp variable=[VariableDef|ID]? targets+=Target+)
	 * </pre>
	 */
	protected void sequence_Question(ISerializationContext context, Question semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Scenario returns Scenario
	 *     CrossRef returns Scenario
	 *
	 * Constraint:
	 *     (name=ID (parameters+=Parameter parameters+=Parameter*)? (variables+=VariableDef | statements+=Statement)*)
	 * </pre>
	 */
	protected void sequence_Scenario(ISerializationContext context, Scenario semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Target returns Target
	 *
	 * Constraint:
	 *     (to=[CrossRef|ID] (expressions+=Exp expressions+=Exp*)? condition=Exp? endingTargets+=EndingTarget*)
	 * </pre>
	 */
	protected void sequence_Target(ISerializationContext context, Target semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableDef returns VariableDef
	 *     CrossRef returns VariableDef
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 * </pre>
	 */
	protected void sequence_VariableDef(ISerializationContext context, VariableDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.CROSS_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.CROSS_REF__NAME));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.VARIABLE_DEF__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.VARIABLE_DEF__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDefAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableDefAccess().getTypeTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
}
