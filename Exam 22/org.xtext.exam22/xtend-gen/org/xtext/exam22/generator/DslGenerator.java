/**
 * generated by Xtext 2.29.0
 */
package org.xtext.exam22.generator;

import com.google.common.collect.Iterators;
import java.util.ArrayList;
import java.util.Arrays;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.xtext.exam22.dsl.Announce;
import org.xtext.exam22.dsl.BoolConstant;
import org.xtext.exam22.dsl.Compare;
import org.xtext.exam22.dsl.Concat;
import org.xtext.exam22.dsl.End;
import org.xtext.exam22.dsl.EndingTarget;
import org.xtext.exam22.dsl.Equal;
import org.xtext.exam22.dsl.Exp;
import org.xtext.exam22.dsl.FuncCall;
import org.xtext.exam22.dsl.Function;
import org.xtext.exam22.dsl.IntConstant;
import org.xtext.exam22.dsl.Model;
import org.xtext.exam22.dsl.MultDiv;
import org.xtext.exam22.dsl.Not;
import org.xtext.exam22.dsl.Parameter;
import org.xtext.exam22.dsl.Parenthesis;
import org.xtext.exam22.dsl.PlusMinus;
import org.xtext.exam22.dsl.Question;
import org.xtext.exam22.dsl.Scenario;
import org.xtext.exam22.dsl.Statement;
import org.xtext.exam22.dsl.StringConstant;
import org.xtext.exam22.dsl.Target;
import org.xtext.exam22.dsl.This;
import org.xtext.exam22.dsl.TypeConstant;
import org.xtext.exam22.dsl.VarRef;
import org.xtext.exam22.dsl.VariableDef;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class DslGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    final Model model = Iterators.<Model>filter(resource.getAllContents(), Model.class).next();
    final String name = model.getName();
    final String[] names = name.split("(?=[A-Z])");
    final String folder = String.join("_", names).toLowerCase();
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("/interactive_fiction/common/Scenario.java");
    fsa.generateFile(_builder.toString(), this.generateCommon());
    final Scenario init = model.getScenarios().get(0);
    boolean _isEmpty = model.getFunctions().isEmpty();
    final boolean externals = (!_isEmpty);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("/interactive_fiction/");
    _builder_1.append(folder);
    _builder_1.append("/Game.java");
    fsa.generateFile(_builder_1.toString(), this.generateGame(folder, init, externals));
    if (externals) {
      StringConcatenation _builder_2 = new StringConcatenation();
      _builder_2.append("/interactive_fiction/");
      _builder_2.append(folder);
      _builder_2.append("/External.java");
      fsa.generateFile(_builder_2.toString(), this.generateExternal(folder, model));
    }
    EList<Scenario> _scenarios = model.getScenarios();
    for (final Scenario scenario : _scenarios) {
      StringConcatenation _builder_3 = new StringConcatenation();
      _builder_3.append("/interactive_fiction/");
      _builder_3.append(folder);
      _builder_3.append("/Scenario");
      String _name = scenario.getName();
      _builder_3.append(_name);
      _builder_3.append(".java");
      fsa.generateFile(_builder_3.toString(), 
        this.generateScenario(folder, model, scenario));
    }
  }

  public CharSequence generateScenario(final String folder, final Model model, final Scenario scenario) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package interactive_fiction.");
    _builder.append(folder);
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("import java.io.IOException;");
    _builder.newLine();
    _builder.append("import interactive_fiction.common.*;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class Scenario");
    String _name = scenario.getName();
    _builder.append(_name);
    _builder.append(" extends Scenario {");
    _builder.newLineIfNotEmpty();
    {
      EList<VariableDef> _variables = scenario.getVariables();
      for(final VariableDef variable : _variables) {
        _builder.append("\t");
        String _javaName = DslGenerator.javaName(variable.getType());
        _builder.append(_javaName, "\t");
        _builder.append(" ");
        String _name_1 = variable.getName();
        _builder.append(_name_1, "\t");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
      }
    }
    {
      EList<Statement> _statements = scenario.getStatements();
      for(final Statement statement : _statements) {
        {
          if ((statement instanceof Question)) {
            {
              Exp _output = ((Question)statement).getOutput();
              if ((_output instanceof Compare)) {
                _builder.append("\t");
                Exp _output_1 = ((Question)statement).getOutput();
                CharSequence _computeExpression = DslGenerator.computeExpression(((Compare) _output_1).getLeft());
                _builder.append(_computeExpression, "\t");
                _builder.append(" __");
                String _name_2 = ((Question)statement).getName();
                _builder.append(_name_2, "\t");
                _builder.append(";");
                _builder.newLineIfNotEmpty();
              } else {
                if (((((Question)statement).getOutput() instanceof FuncCall) && (((FuncCall) ((Question)statement).getOutput()).getRef() instanceof Function))) {
                  _builder.append("\t");
                  Exp _output_2 = ((Question)statement).getOutput();
                  Function _ref = ((FuncCall) _output_2).getRef();
                  String _javaName_1 = DslGenerator.javaName(((Function) _ref).getTypes().get(0));
                  _builder.append(_javaName_1, "\t");
                  _builder.append(" __");
                  String _name_3 = ((Question)statement).getName();
                  _builder.append(_name_3, "\t");
                  _builder.append(";");
                  _builder.newLineIfNotEmpty();
                } else {
                  _builder.append("\t");
                  CharSequence _computeExpression_1 = DslGenerator.computeExpression(((Question)statement).getOutput());
                  _builder.append(_computeExpression_1, "\t");
                  _builder.append(" __");
                  String _name_4 = ((Question)statement).getName();
                  _builder.append(_name_4, "\t");
                  _builder.append(";");
                  _builder.newLineIfNotEmpty();
                }
              }
            }
          }
        }
      }
    }
    _builder.append("\t");
    _builder.newLine();
    {
      if (((!model.getFunctions().isEmpty()) || (!scenario.getParameters().isEmpty()))) {
        _builder.append("\t");
        final ArrayList<String> params = new ArrayList<String>();
        _builder.newLineIfNotEmpty();
        {
          EList<Parameter> _parameters = scenario.getParameters();
          for(final Parameter parameter : _parameters) {
            _builder.append("\t");
            String _javaName_2 = DslGenerator.javaName(parameter.getType());
            String _plus = (_javaName_2 + " ");
            String _name_5 = parameter.getName();
            String _plus_1 = (_plus + _name_5);
            final boolean t = params.add(_plus_1);
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            String _javaName_3 = DslGenerator.javaName(parameter.getType());
            String _plus_2 = (_javaName_3 + " ");
            String _name_6 = parameter.getName();
            String _plus_3 = (_plus_2 + _name_6);
            _builder.append(_plus_3, "\t");
            _builder.append(";");
            _builder.newLineIfNotEmpty();
          }
        }
        {
          boolean _isEmpty = model.getFunctions().isEmpty();
          boolean _not = (!_isEmpty);
          if (_not) {
            _builder.append("\t");
            final boolean t_1 = params.add("External external");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("External external;");
            _builder.newLine();
          }
        }
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("Scenario");
        String _name_7 = scenario.getName();
        _builder.append(_name_7, "\t");
        _builder.append("(");
        String _join = String.join(",", params);
        _builder.append(_join, "\t");
        _builder.append(") {");
        _builder.newLineIfNotEmpty();
        {
          EList<Parameter> _parameters_1 = scenario.getParameters();
          for(final Parameter parameter_1 : _parameters_1) {
            _builder.append("\t");
            _builder.append("\t");
            _builder.append("this.");
            String _name_8 = parameter_1.getName();
            _builder.append(_name_8, "\t\t");
            _builder.append(" = ");
            String _name_9 = parameter_1.getName();
            _builder.append(_name_9, "\t\t");
            _builder.append(";");
            _builder.newLineIfNotEmpty();
          }
        }
        {
          boolean _isEmpty_1 = model.getFunctions().isEmpty();
          boolean _not_1 = (!_isEmpty_1);
          if (_not_1) {
            _builder.append("\t");
            _builder.append("\t");
            _builder.append("this.external = external;");
            _builder.newLine();
          }
        }
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
      }
    }
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public String interact() throws IOException {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("nextInteraction = \"");
    String _name_10 = scenario.getStatements().get(0).getName();
    _builder.append(_name_10, "\t\t");
    _builder.append("\";");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("while(true){");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("switch(nextInteraction){");
    _builder.newLine();
    {
      EList<Statement> _statements_1 = scenario.getStatements();
      for(final Statement statement_1 : _statements_1) {
        _builder.append("\t\t\t\t");
        CharSequence _computeStatement = DslGenerator.computeStatement(statement_1, model);
        _builder.append(_computeStatement, "\t\t\t\t");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t\t\t\t");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }

  protected static CharSequence _computeStatement(final Announce announce, final Model model) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("case \"");
    String _name = announce.getName();
    _builder.append(_name);
    _builder.append("\":");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("System.out.println(");
    CharSequence _computeExpression = DslGenerator.computeExpression(announce.getExpression());
    _builder.append(_computeExpression, "\t");
    _builder.append(");");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    CharSequence _targets = DslGenerator.targets("", announce.getTargets(), model);
    _builder.append(_targets, "\t");
    _builder.newLineIfNotEmpty();
    return _builder;
  }

  protected static CharSequence _computeStatement(final Question question, final Model model) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("case \"");
    String _name = question.getName();
    _builder.append(_name);
    _builder.append("\":");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("System.out.println(");
    CharSequence _computeExpression = DslGenerator.computeExpression(question.getExpression());
    _builder.append(_computeExpression, "\t");
    _builder.append(");");
    _builder.newLineIfNotEmpty();
    {
      boolean _contains = DslGenerator.computeExpression(question.getOutput()).toString().contains("int");
      if (_contains) {
        _builder.append("\t");
        _builder.append("try {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("__");
        String _name_1 = question.getName();
        _builder.append(_name_1, "\t\t");
        _builder.append(" = Integer.parseInt(br.readLine());");
        _builder.newLineIfNotEmpty();
        {
          VariableDef _variable = question.getVariable();
          boolean _tripleNotEquals = (_variable != null);
          if (_tripleNotEquals) {
            _builder.append("\t");
            _builder.append("\t");
            String _name_2 = question.getVariable().getName();
            _builder.append(_name_2, "\t\t");
            _builder.append(" = __");
            String _name_3 = question.getName();
            _builder.append(_name_3, "\t\t");
            _builder.append(";");
            _builder.newLineIfNotEmpty();
          }
        }
        {
          Exp _output = question.getOutput();
          if ((_output instanceof Compare)) {
            _builder.append("\t");
            _builder.append("\t");
            _builder.append("if(!");
            String _string = DslGenerator.computeExpression(question.getOutput()).toString();
            String _name_4 = question.getName();
            String _plus = ("__" + _name_4);
            String _replace = _string.replace("int", _plus);
            _builder.append(_replace, "\t\t");
            _builder.append("){");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("\t");
            _builder.append("\t");
            _builder.append("break;");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t");
            _builder.append("}");
            _builder.newLine();
          }
        }
        _builder.append("\t");
        _builder.append("\t");
        String _name_5 = question.getName();
        String _plus_1 = ("__" + _name_5);
        CharSequence _targets = DslGenerator.targets(_plus_1, question.getTargets(), model);
        _builder.append(_targets, "\t\t");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("} catch (Exception ex) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("break;");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
      } else {
        _builder.append("\t");
        _builder.append("__");
        String _name_6 = question.getName();
        _builder.append(_name_6, "\t");
        _builder.append(" = br.readLine();");
        _builder.newLineIfNotEmpty();
        {
          VariableDef _variable_1 = question.getVariable();
          boolean _tripleNotEquals_1 = (_variable_1 != null);
          if (_tripleNotEquals_1) {
            _builder.append("\t");
            String _name_7 = question.getVariable().getName();
            _builder.append(_name_7, "\t");
            _builder.append(" = __");
            String _name_8 = question.getName();
            _builder.append(_name_8, "\t");
            _builder.append(";");
            _builder.newLineIfNotEmpty();
          }
        }
        {
          if (((question.getOutput() instanceof FuncCall) && (((FuncCall) question.getOutput()).getRef() instanceof Function))) {
            _builder.append("\t");
            _builder.append("if(!");
            String _string_1 = DslGenerator.computeExpression(question.getOutput()).toString();
            Exp _output_1 = question.getOutput();
            Function _ref = ((FuncCall) _output_1).getRef();
            String _javaName = DslGenerator.javaName(((Function) _ref).getTypes().get(0));
            String _name_9 = question.getName();
            String _plus_2 = ("__" + _name_9);
            String _replace_1 = _string_1.replace(_javaName, _plus_2);
            _builder.append(_replace_1, "\t");
            _builder.append("){");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("\t");
            _builder.append("break;");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("}");
            _builder.newLine();
          }
        }
        _builder.append("\t");
        String _name_10 = question.getName();
        String _plus_3 = ("__" + _name_10);
        CharSequence _targets_1 = DslGenerator.targets(_plus_3, question.getTargets(), model);
        _builder.append(_targets_1, "\t");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }

  public static CharSequence targets(final String thisVar, final EList<Target> targets, final Model model) {
    StringConcatenation _builder = new StringConcatenation();
    {
      for(final Target target : targets) {
        {
          Exp _condition = target.getCondition();
          boolean _tripleNotEquals = (_condition != null);
          if (_tripleNotEquals) {
            _builder.append("if(");
            String _replace = DslGenerator.computeExpression(target.getCondition()).toString().replace("this", thisVar);
            _builder.append(_replace);
            _builder.append("){");
            _builder.newLineIfNotEmpty();
          }
        }
        {
          boolean _isEmpty = target.getEndingTargets().isEmpty();
          boolean _not = (!_isEmpty);
          if (_not) {
            final ArrayList<String> params = new ArrayList<String>();
            _builder.newLineIfNotEmpty();
            {
              EList<Exp> _expressions = target.getExpressions();
              for(final Exp parameter : _expressions) {
                final boolean t = params.add(DslGenerator.computeExpression(parameter).toString().replace("this", thisVar));
                _builder.newLineIfNotEmpty();
              }
            }
            {
              boolean _isEmpty_1 = model.getFunctions().isEmpty();
              boolean _not_1 = (!_isEmpty_1);
              if (_not_1) {
                final boolean t_1 = params.add("external");
                _builder.newLineIfNotEmpty();
              }
            }
            _builder.append("calledScenarioEnd = new Scenario");
            String _name = target.getTo().getName();
            _builder.append(_name);
            _builder.append("(");
            String _join = String.join(",", params);
            _builder.append(_join);
            _builder.append(").interact();");
            _builder.newLineIfNotEmpty();
            {
              EList<EndingTarget> _endingTargets = target.getEndingTargets();
              for(final EndingTarget endingTarget : _endingTargets) {
                _builder.append("if(calledScenarioEnd.equals(\"");
                String _name_1 = endingTarget.getEnd().getName();
                _builder.append(_name_1);
                _builder.append("\")){");
                _builder.newLineIfNotEmpty();
                _builder.append("\t");
                _builder.append("nextInteraction = \"");
                String _name_2 = endingTarget.getTarget().getTo().getName();
                _builder.append(_name_2, "\t");
                _builder.append("\";");
                _builder.newLineIfNotEmpty();
                _builder.append("\t");
                _builder.append("break;");
                _builder.newLine();
                _builder.append("}");
                _builder.newLine();
              }
            }
          } else {
            _builder.append("nextInteraction = \"");
            String _name_3 = target.getTo().getName();
            _builder.append(_name_3);
            _builder.append("\";");
            _builder.newLineIfNotEmpty();
            _builder.append("break;");
            _builder.newLine();
          }
        }
        {
          Exp _condition_1 = target.getCondition();
          boolean _tripleNotEquals_1 = (_condition_1 != null);
          if (_tripleNotEquals_1) {
            _builder.append("}");
            _builder.newLine();
          }
        }
      }
    }
    return _builder;
  }

  protected static CharSequence _computeStatement(final End end, final Model model) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("case \"");
    String _name = end.getName();
    _builder.append(_name);
    _builder.append("\":");
    _builder.newLineIfNotEmpty();
    {
      Exp _expression = end.getExpression();
      boolean _tripleNotEquals = (_expression != null);
      if (_tripleNotEquals) {
        _builder.append("\t");
        _builder.append("System.out.println(");
        CharSequence _computeExpression = DslGenerator.computeExpression(end.getExpression());
        _builder.append(_computeExpression, "\t");
        _builder.append(");");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.append("return \"");
    String _name_1 = end.getName();
    _builder.append(_name_1, "\t");
    _builder.append("\";");
    _builder.newLineIfNotEmpty();
    return _builder;
  }

  protected static CharSequence _computeExpression(final org.xtext.exam22.dsl.Boolean bool) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(");
    CharSequence _computeExpression = DslGenerator.computeExpression(bool.getLeft());
    _builder.append(_computeExpression);
    _builder.append(" ");
    String _op = bool.getOp();
    _builder.append(_op);
    _builder.append(" ");
    CharSequence _computeExpression_1 = DslGenerator.computeExpression(bool.getRight());
    _builder.append(_computeExpression_1);
    _builder.append(")");
    return _builder;
  }

  protected static CharSequence _computeExpression(final Equal equal) {
    CharSequence _xifexpression = null;
    if (((equal.getLeft() instanceof StringConstant) || (equal.getRight() instanceof StringConstant))) {
      CharSequence _switchResult = null;
      String _op = equal.getOp();
      if (_op != null) {
        switch (_op) {
          case "==":
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("(");
            CharSequence _computeExpression = DslGenerator.computeExpression(equal.getLeft());
            _builder.append(_computeExpression);
            _builder.append(").equals(");
            CharSequence _computeExpression_1 = DslGenerator.computeExpression(equal.getRight());
            _builder.append(_computeExpression_1);
            _builder.append(")");
            _switchResult = _builder;
            break;
          case "!=":
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("!(");
            CharSequence _computeExpression_2 = DslGenerator.computeExpression(equal.getLeft());
            _builder_1.append(_computeExpression_2);
            _builder_1.append(").equals(");
            CharSequence _computeExpression_3 = DslGenerator.computeExpression(equal.getRight());
            _builder_1.append(_computeExpression_3);
            _builder_1.append(")");
            _switchResult = _builder_1;
            break;
          default:
            StringConcatenation _builder_2 = new StringConcatenation();
            _switchResult = _builder_2;
            break;
        }
      } else {
        StringConcatenation _builder_2 = new StringConcatenation();
        _switchResult = _builder_2;
      }
      _xifexpression = _switchResult;
    } else {
      StringConcatenation _builder_3 = new StringConcatenation();
      _builder_3.append("(");
      CharSequence _computeExpression_4 = DslGenerator.computeExpression(equal.getLeft());
      _builder_3.append(_computeExpression_4);
      _builder_3.append(" ");
      String _op_1 = equal.getOp();
      _builder_3.append(_op_1);
      _builder_3.append(" ");
      CharSequence _computeExpression_5 = DslGenerator.computeExpression(equal.getRight());
      _builder_3.append(_computeExpression_5);
      _builder_3.append(")");
      _xifexpression = _builder_3;
    }
    return _xifexpression;
  }

  protected static CharSequence _computeExpression(final Compare compare) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(");
    CharSequence _computeExpression = DslGenerator.computeExpression(compare.getLeft());
    _builder.append(_computeExpression);
    _builder.append(" ");
    String _op = compare.getOp();
    _builder.append(_op);
    _builder.append(" ");
    CharSequence _computeExpression_1 = DslGenerator.computeExpression(compare.getRight());
    _builder.append(_computeExpression_1);
    _builder.append(")");
    return _builder;
  }

  protected static CharSequence _computeExpression(final Concat concat) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(");
    CharSequence _computeExpression = DslGenerator.computeExpression(concat.getLeft());
    _builder.append(_computeExpression);
    _builder.append(" + ");
    CharSequence _computeExpression_1 = DslGenerator.computeExpression(concat.getRight());
    _builder.append(_computeExpression_1);
    _builder.append(")");
    return _builder;
  }

  protected static CharSequence _computeExpression(final PlusMinus plusMinus) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(");
    CharSequence _computeExpression = DslGenerator.computeExpression(plusMinus.getLeft());
    _builder.append(_computeExpression);
    _builder.append(" ");
    String _op = plusMinus.getOp();
    _builder.append(_op);
    _builder.append(" ");
    CharSequence _computeExpression_1 = DslGenerator.computeExpression(plusMinus.getRight());
    _builder.append(_computeExpression_1);
    _builder.append(")");
    return _builder;
  }

  protected static CharSequence _computeExpression(final MultDiv multDiv) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(");
    CharSequence _computeExpression = DslGenerator.computeExpression(multDiv.getLeft());
    _builder.append(_computeExpression);
    _builder.append(" ");
    String _op = multDiv.getOp();
    _builder.append(_op);
    _builder.append(" ");
    CharSequence _computeExpression_1 = DslGenerator.computeExpression(multDiv.getRight());
    _builder.append(_computeExpression_1);
    _builder.append(")");
    return _builder;
  }

  protected static CharSequence _computeExpression(final IntConstant primitive) {
    StringConcatenation _builder = new StringConcatenation();
    int _value = primitive.getValue();
    _builder.append(_value);
    return _builder;
  }

  protected static CharSequence _computeExpression(final StringConstant primitive) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("\"");
    String _value = primitive.getValue();
    _builder.append(_value);
    _builder.append("\"");
    return _builder;
  }

  protected static CharSequence _computeExpression(final BoolConstant primitive) {
    StringConcatenation _builder = new StringConcatenation();
    String _value = primitive.getValue();
    _builder.append(_value);
    return _builder;
  }

  protected static CharSequence _computeExpression(final Not primitive) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("!(");
    CharSequence _computeExpression = DslGenerator.computeExpression(primitive.getExp());
    _builder.append(_computeExpression);
    _builder.append(")");
    return _builder;
  }

  protected static CharSequence _computeExpression(final TypeConstant primitive) {
    StringConcatenation _builder = new StringConcatenation();
    String _javaName = DslGenerator.javaName(primitive.getType());
    _builder.append(_javaName);
    return _builder;
  }

  protected static CharSequence _computeExpression(final This primitive) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("this");
    return _builder;
  }

  protected static CharSequence _computeExpression(final VarRef primitive) {
    StringConcatenation _builder = new StringConcatenation();
    String _name = primitive.getRef().getName();
    _builder.append(_name);
    return _builder;
  }

  protected static CharSequence _computeExpression(final FuncCall primitive) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("external.");
    String _name = primitive.getRef().getName();
    _builder.append(_name);
    _builder.append("(");
    {
      EList<Exp> _expressions = primitive.getExpressions();
      boolean _hasElements = false;
      for(final Exp expression : _expressions) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(",", "");
        }
        CharSequence _computeExpression = DslGenerator.computeExpression(expression);
        _builder.append(_computeExpression);
      }
    }
    _builder.append(")");
    return _builder;
  }

  protected static CharSequence _computeExpression(final Parenthesis primitive) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(");
    CharSequence _computeExpression = DslGenerator.computeExpression(primitive.getExp());
    _builder.append(_computeExpression);
    _builder.append(")");
    return _builder;
  }

  public CharSequence generateExternal(final String folder, final Model model) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package interactive_fiction.");
    _builder.append(folder);
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("public interface External {");
    _builder.newLine();
    _builder.append("\t");
    int i = 0;
    _builder.newLineIfNotEmpty();
    {
      EList<Function> _functions = model.getFunctions();
      for(final Function function : _functions) {
        _builder.append("\t");
        _builder.append("public ");
        String _javaName = DslGenerator.javaName(function.getReturnType());
        _builder.append(_javaName, "\t");
        _builder.append(" ");
        String _name = function.getName();
        _builder.append(_name, "\t");
        _builder.append("(");
        {
          EList<String> _types = function.getTypes();
          boolean _hasElements = false;
          for(final String type : _types) {
            if (!_hasElements) {
              _hasElements = true;
            } else {
              _builder.appendImmediate(",", "\t");
            }
            String _javaName_1 = DslGenerator.javaName(type);
            _builder.append(_javaName_1, "\t");
            _builder.append(" param");
            int _plusPlus = i++;
            _builder.append(_plusPlus, "\t");
          }
        }
        _builder.append(");");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    return _builder;
  }

  public static String javaName(final String type) {
    String _switchResult = null;
    if (type != null) {
      switch (type) {
        case "text":
          _switchResult = "String";
          break;
        case "number":
          _switchResult = "int";
          break;
        default:
          _switchResult = type;
          break;
      }
    } else {
      _switchResult = type;
    }
    return _switchResult;
  }

  public CharSequence generateGame(final String folder, final Scenario scenario, final boolean external) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package interactive_fiction.");
    _builder.append(folder);
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("import java.io.IOException;");
    _builder.newLine();
    _builder.append("import interactive_fiction.common.*;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("public class Game{");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public Scenario start;");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public Game(");
    String _xifexpression = null;
    if (external) {
      _xifexpression = "External external";
    } else {
      _xifexpression = "";
    }
    _builder.append(_xifexpression, "\t");
    _builder.append("){");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("this.start = new Scenario");
    String _name = scenario.getName();
    _builder.append(_name, "\t\t");
    _builder.append("(");
    String _xifexpression_1 = null;
    if (external) {
      _xifexpression_1 = "external";
    } else {
      _xifexpression_1 = "";
    }
    _builder.append(_xifexpression_1, "\t\t");
    _builder.append(");");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public void play()  throws IOException {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("start.interact();");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }

  public CharSequence generateCommon() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package interactive_fiction.common;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.io.BufferedReader;");
    _builder.newLine();
    _builder.append("import java.io.InputStreamReader;");
    _builder.newLine();
    _builder.append("import java.io.IOException;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("public abstract class Scenario {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("protected static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("protected String nextInteraction;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("protected String calledScenarioEnd;");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public abstract String interact() throws IOException ;");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public static void changeInput(InputStreamReader streamReader) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("br = new BufferedReader(streamReader);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }

  public static CharSequence computeStatement(final Statement announce, final Model model) {
    if (announce instanceof Announce) {
      return _computeStatement((Announce)announce, model);
    } else if (announce instanceof End) {
      return _computeStatement((End)announce, model);
    } else if (announce instanceof Question) {
      return _computeStatement((Question)announce, model);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(announce, model).toString());
    }
  }

  public static CharSequence computeExpression(final Exp primitive) {
    if (primitive instanceof BoolConstant) {
      return _computeExpression((BoolConstant)primitive);
    } else if (primitive instanceof org.xtext.exam22.dsl.Boolean) {
      return _computeExpression((org.xtext.exam22.dsl.Boolean)primitive);
    } else if (primitive instanceof Compare) {
      return _computeExpression((Compare)primitive);
    } else if (primitive instanceof Concat) {
      return _computeExpression((Concat)primitive);
    } else if (primitive instanceof Equal) {
      return _computeExpression((Equal)primitive);
    } else if (primitive instanceof FuncCall) {
      return _computeExpression((FuncCall)primitive);
    } else if (primitive instanceof IntConstant) {
      return _computeExpression((IntConstant)primitive);
    } else if (primitive instanceof MultDiv) {
      return _computeExpression((MultDiv)primitive);
    } else if (primitive instanceof Not) {
      return _computeExpression((Not)primitive);
    } else if (primitive instanceof Parenthesis) {
      return _computeExpression((Parenthesis)primitive);
    } else if (primitive instanceof PlusMinus) {
      return _computeExpression((PlusMinus)primitive);
    } else if (primitive instanceof StringConstant) {
      return _computeExpression((StringConstant)primitive);
    } else if (primitive instanceof This) {
      return _computeExpression((This)primitive);
    } else if (primitive instanceof TypeConstant) {
      return _computeExpression((TypeConstant)primitive);
    } else if (primitive instanceof VarRef) {
      return _computeExpression((VarRef)primitive);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(primitive).toString());
    }
  }
}
