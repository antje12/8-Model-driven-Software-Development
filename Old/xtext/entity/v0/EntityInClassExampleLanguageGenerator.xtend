/*
 * generated by Xtext 2.12.0
 */
package dk.sdu.mmmi.mdsd.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.entityInClassExampleLanguage.Entity
import dk.sdu.mmmi.mdsd.entityInClassExampleLanguage.Attribute
import dk.sdu.mmmi.mdsd.entityInClassExampleLanguage.Relation
import dk.sdu.mmmi.mdsd.entityInClassExampleLanguage.Type
import java.util.List
import java.util.ArrayList
import java.util.Iterator
import org.eclipse.xtend.lib.annotations.Data
import java.util.Collection
import java.util.Map
import java.util.HashMap
import java.util.HashSet
import java.util.Set
import dk.sdu.mmmi.mdsd.generator.EntityInClassExampleLanguageGenerator.RelationInformation

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class EntityInClassExampleLanguageGenerator extends AbstractGenerator {

	var Set<RelationInformation> relationInformation

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		relationInformation = resource.allContents.filter(Entity).collectRelationInformation
		resource.allContents.filter(Entity).forEach[generateEntityFile(fsa)]
	}
	
	def generateEntityFile(Entity entity, IFileSystemAccess2 fsa) {
		fsa.generateFile(entity.name+".java",entity.generateEntity)
	}
	
	def CharSequence generateEntity(Entity entity) '''
	// Generated file, do not edit
	import java.util.*;
	public class «entity.name»«IF entity.zuper!==null» extends «entity.zuper.name»«ENDIF» {
		«entity.generateConstructor»
		«FOR d: entity.declarations.filter(Attribute)»
		«d.generateAttribute»
		«ENDFOR»
		«FOR ri: relationInformation.filter[r | r.from.equals(entity)]»
		«ri.generateRelation»
		«ENDFOR»
	}
	'''
	
	def generateConstructor(Entity entity) '''
		public «entity.name»(«FOR a:entity.allAttributes SEPARATOR ","»«a.generateParameter(entity)»«ENDFOR») {
			«IF entity.zuper!==null»
			super(«FOR a: entity.zuper.allAttributes SEPARATOR ","»__«a»«ENDFOR»);
			«ENDIF»
			«FOR a: entity.declarations.filter(Attribute)»
			_«a.name» = __«a.name»;
			«ENDFOR»
		}
	'''
	
	def generateParameter(String name, Entity entity) '''«name.findType(entity).name» __«name»'''
	
	def generateAttribute(Attribute attribute) '''
		// Attribute «attribute.name»
		private «attribute.type.name» _«attribute.name»;
		public «attribute.type.name» get«attribute.name.toFirstUpper»() { return _«attribute.name»; }
		public void set«attribute.name.toFirstUpper»(«attribute.type.name» x) { _«attribute.name» = x; }
	'''
	
	def generateRelation(RelationInformation ri) '''
	// Relation «ri.fromRelationName»
	«IF ri.isMultiple»
	private List<«ri.to.name»> _«ri.fromRelationName» = new ArrayList<>();
	public void set«ri.fromRelationName.toFirstUpper»(«ri.to.name» x) {
		_«ri.fromRelationName».add(x);
		«IF ri.hasInverse»
		x.set«ri.inverseRelationName.toFirstUpper»(this);
		«ENDIF»
	}
	public Collection<«ri.to.name»> get«ri.fromRelationName.toFirstUpper»() {
		return Collections.unmodifiableCollection(_«ri.fromRelationName»);
	}
	«ELSE»
	private «ri.to.name» _«ri.fromRelationName»;
	public void set«ri.fromRelationName.toFirstUpper»(«ri.to.name» x) {
		_«ri.fromRelationName» = x;
		«IF ri.hasInverse»
		x.set«ri.inverseRelationName.toFirstUpper»(this);
		«ENDIF»
	}
	public Collection<«ri.to.name»> get«ri.fromRelationName.toFirstUpper»() {
		return Collections.singleton(_«ri.fromRelationName»);
	}
	«ENDIF»
	'''

	
	// Helper methods for attributes
	
	def List<String> allAttributes(Entity e) {
		e.collectNames(new ArrayList)
	}
	
	def List<String> collectNames(Entity entity, List<String> names) {
		names.addAll(entity.declarations.filter(Attribute).map[name])
		if(entity.zuper!==null) entity.zuper.collectNames(names) else names
	}
	
	def Type findType(String n, Entity entity) {
		for(Attribute a: entity.declarations.filter(Attribute)) {
			if(a.name.equals(n)) return a.type
		}
		n.findType(entity.zuper)
	}

	// Helper methods for relations
	
	@Data
	static class RelationInformation {
		Entity from
		Entity to
		String fromRelationName
		boolean hasInverse
		boolean isMultiple
		String inverseRelationName
	}
	
	def Set<RelationInformation> collectRelationInformation(Iterator<Entity> entities) {
		val result = new HashSet<RelationInformation>
		entities.forEach[entity | entity.declarations.filter(Relation).forEach[relation |
				result.add(new RelationInformation(entity,relation.typeName,relation.name,relation.inverse_name!==null,relation.isMultiple,relation.inverse_name))
				if(relation.inverse_name!==null)
					result.add(new RelationInformation(relation.typeName,entity,relation.inverse_name,true,false,relation.name))
			]
		]
		result
	}
	
	
}
