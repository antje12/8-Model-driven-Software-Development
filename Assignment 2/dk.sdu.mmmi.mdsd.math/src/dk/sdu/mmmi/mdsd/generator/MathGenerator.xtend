/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.Exp
import dk.sdu.mmmi.mdsd.math.PlusMinus
import dk.sdu.mmmi.mdsd.math.MultDiv
import dk.sdu.mmmi.mdsd.math.Let
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Number
import dk.sdu.mmmi.mdsd.math.Parenthesis
import dk.sdu.mmmi.mdsd.math.VariableUse

import java.util.HashMap
import java.util.Map

import javax.swing.JOptionPane

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	static Map<String, Integer> variables;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = resource.allContents.filter(MathExp).next
		val result = math.compute

		// You can replace with hovering, see Bettini Chapter 8
		result.displayPanel
	}

	//
	// Compute function: computes value of expression
	//
	def static compute(MathExp math) {
		variables = new HashMap()
		math.variables.forEach[v|variables.put(v.name, v.value.computeExp(new HashMap()))]
		return variables
	}

	def static int computeExp(Exp exp, Map<String, Integer> locals) {
		switch exp {
			PlusMinus: {
				val left = exp.left.computeExp(locals)
				val right = exp.right.computeExp(locals)
				if (exp.operator instanceof Plus) 
					{left + right}
				else 
					{left - right}
			}
			MultDiv: {
				val left = exp.left.computeExp(locals)
				val right = exp.right.computeExp(locals)
				if (exp.operator instanceof Mult)
					{left * right}
				else 
					{left / right}
			}
			Let: {
				var layer = new HashMap<String, Integer>(locals)
				val local = exp.value.computeExp(locals)
				layer.put(exp.name, local)
				exp.in.computeExp(layer)
			}
			default:
				exp.computePrim(locals)
		}
	}

	def static int computePrim(Exp factor, Map<String, Integer> locals) {
		switch factor {
			Number: factor.value
			Parenthesis: factor.exp.computeExp(locals)
			VariableUse: {
				if (locals.containsKey(factor.ref.name)){
					locals.get(factor.ref.name)
				}
				else if (variables.containsKey(factor.ref.name)){
					variables.get(factor.ref.name)
				}
				else {
					factor.ref.value.computeExp(locals)
				}
			}
			default: 0
		}
	}

	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
			resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
		}

		JOptionPane.showMessageDialog(null, resultString, "Math Language", JOptionPane.INFORMATION_MESSAGE)
	}

}
