/*
 * generated by Xtext 2.29.0
 */
package org.xtext.ui23.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.ui23.dsl.Button;
import org.xtext.ui23.dsl.Compare;
import org.xtext.ui23.dsl.Concat;
import org.xtext.ui23.dsl.DslPackage;
import org.xtext.ui23.dsl.Equal;
import org.xtext.ui23.dsl.Form;
import org.xtext.ui23.dsl.FormUse;
import org.xtext.ui23.dsl.FuncCall;
import org.xtext.ui23.dsl.Function;
import org.xtext.ui23.dsl.InputText;
import org.xtext.ui23.dsl.IntConstant;
import org.xtext.ui23.dsl.Label;
import org.xtext.ui23.dsl.Layout;
import org.xtext.ui23.dsl.Length;
import org.xtext.ui23.dsl.MultDiv;
import org.xtext.ui23.dsl.Not;
import org.xtext.ui23.dsl.Parenthesis;
import org.xtext.ui23.dsl.PlusMinus;
import org.xtext.ui23.dsl.StringConstant;
import org.xtext.ui23.dsl.TypeConstant;
import org.xtext.ui23.dsl.UI23;
import org.xtext.ui23.dsl.VarRef;
import org.xtext.ui23.services.DslGrammarAccess;

@SuppressWarnings("all")
public class DslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DslPackage.BOOLEAN:
				sequence_Boolean(context, (org.xtext.ui23.dsl.Boolean) semanticObject); 
				return; 
			case DslPackage.BUTTON:
				sequence_Button(context, (Button) semanticObject); 
				return; 
			case DslPackage.COMPARE:
				sequence_Compare(context, (Compare) semanticObject); 
				return; 
			case DslPackage.CONCAT:
				sequence_Concat(context, (Concat) semanticObject); 
				return; 
			case DslPackage.EQUAL:
				sequence_Equal(context, (Equal) semanticObject); 
				return; 
			case DslPackage.FORM:
				sequence_Form(context, (Form) semanticObject); 
				return; 
			case DslPackage.FORM_USE:
				sequence_FormUse(context, (FormUse) semanticObject); 
				return; 
			case DslPackage.FUNC_CALL:
				sequence_Primitive(context, (FuncCall) semanticObject); 
				return; 
			case DslPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case DslPackage.INPUT_TEXT:
				sequence_InputText(context, (InputText) semanticObject); 
				return; 
			case DslPackage.INT_CONSTANT:
				sequence_Primitive(context, (IntConstant) semanticObject); 
				return; 
			case DslPackage.LABEL:
				sequence_Label(context, (Label) semanticObject); 
				return; 
			case DslPackage.LAYOUT:
				sequence_Layout(context, (Layout) semanticObject); 
				return; 
			case DslPackage.LENGTH:
				sequence_Primitive(context, (Length) semanticObject); 
				return; 
			case DslPackage.MULT_DIV:
				sequence_MultDiv(context, (MultDiv) semanticObject); 
				return; 
			case DslPackage.NOT:
				sequence_Primitive(context, (Not) semanticObject); 
				return; 
			case DslPackage.PARAMETER:
				sequence_Parameter(context, (org.xtext.ui23.dsl.Parameter) semanticObject); 
				return; 
			case DslPackage.PARENTHESIS:
				sequence_Primitive(context, (Parenthesis) semanticObject); 
				return; 
			case DslPackage.PLUS_MINUS:
				sequence_PlusMinus(context, (PlusMinus) semanticObject); 
				return; 
			case DslPackage.STRING_CONSTANT:
				sequence_Primitive(context, (StringConstant) semanticObject); 
				return; 
			case DslPackage.TYPE_CONSTANT:
				sequence_Primitive(context, (TypeConstant) semanticObject); 
				return; 
			case DslPackage.UI23:
				sequence_UI23(context, (UI23) semanticObject); 
				return; 
			case DslPackage.VAR_REF:
				sequence_Primitive(context, (VarRef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Boolean
	 *     Boolean returns Boolean
	 *     Boolean.Boolean_1_0 returns Boolean
	 *
	 * Constraint:
	 *     (left=Boolean_Boolean_1_0 (op='&&' | op='||') right=Equal)
	 * </pre>
	 */
	protected void sequence_Boolean(ISerializationContext context, org.xtext.ui23.dsl.Boolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Button
	 *     Element returns Button
	 *     Button returns Button
	 *
	 * Constraint:
	 *     (validate='*'? name=ID exp=Exp)
	 * </pre>
	 */
	protected void sequence_Button(ISerializationContext context, Button semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Compare
	 *     Boolean returns Compare
	 *     Boolean.Boolean_1_0 returns Compare
	 *     Equal returns Compare
	 *     Equal.Equal_1_0 returns Compare
	 *     Compare returns Compare
	 *     Compare.Compare_1_0 returns Compare
	 *
	 * Constraint:
	 *     (left=Compare_Compare_1_0 (op='&lt;' | op='&gt;' | op='&lt;=' | op='&gt;=') right=Concat)
	 * </pre>
	 */
	protected void sequence_Compare(ISerializationContext context, Compare semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Concat
	 *     Boolean returns Concat
	 *     Boolean.Boolean_1_0 returns Concat
	 *     Equal returns Concat
	 *     Equal.Equal_1_0 returns Concat
	 *     Compare returns Concat
	 *     Compare.Compare_1_0 returns Concat
	 *     Concat returns Concat
	 *     Concat.Concat_1_0 returns Concat
	 *
	 * Constraint:
	 *     (left=Concat_Concat_1_0 right=PlusMinus)
	 * </pre>
	 */
	protected void sequence_Concat(ISerializationContext context, Concat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.CONCAT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.CONCAT__LEFT));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.CONCAT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.CONCAT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConcatAccess().getConcatLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConcatAccess().getRightPlusMinusParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Equal
	 *     Boolean returns Equal
	 *     Boolean.Boolean_1_0 returns Equal
	 *     Equal returns Equal
	 *     Equal.Equal_1_0 returns Equal
	 *
	 * Constraint:
	 *     (left=Equal_Equal_1_0 (op='==' | op='!=') right=Compare)
	 * </pre>
	 */
	protected void sequence_Equal(ISerializationContext context, Equal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns FormUse
	 *     FormUse returns FormUse
	 *
	 * Constraint:
	 *     (form=[Form|ID] (exps+=Exp exps+=Exp*)?)
	 * </pre>
	 */
	protected void sequence_FormUse(ISerializationContext context, FormUse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Form returns Form
	 *
	 * Constraint:
	 *     (name=ID (parameters+=Parameter parameters+=Parameter*)? layout=Layout)
	 * </pre>
	 */
	protected void sequence_Form(ISerializationContext context, Form semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (name=ID (types+=Type types+=Type*)? returnType=Type)
	 * </pre>
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns InputText
	 *     Element returns InputText
	 *     InputText returns InputText
	 *     CrossRef returns InputText
	 *
	 * Constraint:
	 *     (name=ID exp=Exp)
	 * </pre>
	 */
	protected void sequence_InputText(ISerializationContext context, InputText semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.CROSS_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.CROSS_REF__NAME));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.ELEMENT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.ELEMENT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputTextAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getInputTextAccess().getExpExpParserRuleCall_3_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Label
	 *     Element returns Label
	 *     Label returns Label
	 *
	 * Constraint:
	 *     exp=Exp
	 * </pre>
	 */
	protected void sequence_Label(ISerializationContext context, Label semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.ELEMENT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.ELEMENT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabelAccess().getExpExpParserRuleCall_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Layout returns Layout
	 *     Component returns Layout
	 *
	 * Constraint:
	 *     ((axis='row' | axis='column') components+=Component*)
	 * </pre>
	 */
	protected void sequence_Layout(ISerializationContext context, Layout semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns MultDiv
	 *     Boolean returns MultDiv
	 *     Boolean.Boolean_1_0 returns MultDiv
	 *     Equal returns MultDiv
	 *     Equal.Equal_1_0 returns MultDiv
	 *     Compare returns MultDiv
	 *     Compare.Compare_1_0 returns MultDiv
	 *     Concat returns MultDiv
	 *     Concat.Concat_1_0 returns MultDiv
	 *     PlusMinus returns MultDiv
	 *     PlusMinus.PlusMinus_1_0 returns MultDiv
	 *     MultDiv returns MultDiv
	 *     MultDiv.MultDiv_1_0 returns MultDiv
	 *
	 * Constraint:
	 *     (left=MultDiv_MultDiv_1_0 (op='*' | op='/') right=Primitive)
	 * </pre>
	 */
	protected void sequence_MultDiv(ISerializationContext context, MultDiv semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *     CrossRef returns Parameter
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, org.xtext.ui23.dsl.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.CROSS_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.CROSS_REF__NAME));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.PARAMETER__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns PlusMinus
	 *     Boolean returns PlusMinus
	 *     Boolean.Boolean_1_0 returns PlusMinus
	 *     Equal returns PlusMinus
	 *     Equal.Equal_1_0 returns PlusMinus
	 *     Compare returns PlusMinus
	 *     Compare.Compare_1_0 returns PlusMinus
	 *     Concat returns PlusMinus
	 *     Concat.Concat_1_0 returns PlusMinus
	 *     PlusMinus returns PlusMinus
	 *     PlusMinus.PlusMinus_1_0 returns PlusMinus
	 *
	 * Constraint:
	 *     (left=PlusMinus_PlusMinus_1_0 (op='+' | op='-') right=MultDiv)
	 * </pre>
	 */
	protected void sequence_PlusMinus(ISerializationContext context, PlusMinus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns FuncCall
	 *     Boolean returns FuncCall
	 *     Boolean.Boolean_1_0 returns FuncCall
	 *     Equal returns FuncCall
	 *     Equal.Equal_1_0 returns FuncCall
	 *     Compare returns FuncCall
	 *     Compare.Compare_1_0 returns FuncCall
	 *     Concat returns FuncCall
	 *     Concat.Concat_1_0 returns FuncCall
	 *     PlusMinus returns FuncCall
	 *     PlusMinus.PlusMinus_1_0 returns FuncCall
	 *     MultDiv returns FuncCall
	 *     MultDiv.MultDiv_1_0 returns FuncCall
	 *     Primitive returns FuncCall
	 *
	 * Constraint:
	 *     (ref=[Function|ID] (exps+=Exp exps+=Exp*)?)
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, FuncCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns IntConstant
	 *     Boolean returns IntConstant
	 *     Boolean.Boolean_1_0 returns IntConstant
	 *     Equal returns IntConstant
	 *     Equal.Equal_1_0 returns IntConstant
	 *     Compare returns IntConstant
	 *     Compare.Compare_1_0 returns IntConstant
	 *     Concat returns IntConstant
	 *     Concat.Concat_1_0 returns IntConstant
	 *     PlusMinus returns IntConstant
	 *     PlusMinus.PlusMinus_1_0 returns IntConstant
	 *     MultDiv returns IntConstant
	 *     MultDiv.MultDiv_1_0 returns IntConstant
	 *     Primitive returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Length
	 *     Boolean returns Length
	 *     Boolean.Boolean_1_0 returns Length
	 *     Equal returns Length
	 *     Equal.Equal_1_0 returns Length
	 *     Compare returns Length
	 *     Compare.Compare_1_0 returns Length
	 *     Concat returns Length
	 *     Concat.Concat_1_0 returns Length
	 *     PlusMinus returns Length
	 *     PlusMinus.PlusMinus_1_0 returns Length
	 *     MultDiv returns Length
	 *     MultDiv.MultDiv_1_0 returns Length
	 *     Primitive returns Length
	 *
	 * Constraint:
	 *     exp=Primitive
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, Length semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.LENGTH__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.LENGTH__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveAccess().getExpPrimitiveParserRuleCall_3_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Not
	 *     Boolean returns Not
	 *     Boolean.Boolean_1_0 returns Not
	 *     Equal returns Not
	 *     Equal.Equal_1_0 returns Not
	 *     Compare returns Not
	 *     Compare.Compare_1_0 returns Not
	 *     Concat returns Not
	 *     Concat.Concat_1_0 returns Not
	 *     PlusMinus returns Not
	 *     PlusMinus.PlusMinus_1_0 returns Not
	 *     MultDiv returns Not
	 *     MultDiv.MultDiv_1_0 returns Not
	 *     Primitive returns Not
	 *
	 * Constraint:
	 *     exp=Primitive
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.NOT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.NOT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveAccess().getExpPrimitiveParserRuleCall_2_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Parenthesis
	 *     Boolean returns Parenthesis
	 *     Boolean.Boolean_1_0 returns Parenthesis
	 *     Equal returns Parenthesis
	 *     Equal.Equal_1_0 returns Parenthesis
	 *     Compare returns Parenthesis
	 *     Compare.Compare_1_0 returns Parenthesis
	 *     Concat returns Parenthesis
	 *     Concat.Concat_1_0 returns Parenthesis
	 *     PlusMinus returns Parenthesis
	 *     PlusMinus.PlusMinus_1_0 returns Parenthesis
	 *     MultDiv returns Parenthesis
	 *     MultDiv.MultDiv_1_0 returns Parenthesis
	 *     Primitive returns Parenthesis
	 *
	 * Constraint:
	 *     exp=Exp
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, Parenthesis semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.PARENTHESIS__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.PARENTHESIS__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveAccess().getExpExpParserRuleCall_7_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns StringConstant
	 *     Boolean returns StringConstant
	 *     Boolean.Boolean_1_0 returns StringConstant
	 *     Equal returns StringConstant
	 *     Equal.Equal_1_0 returns StringConstant
	 *     Compare returns StringConstant
	 *     Compare.Compare_1_0 returns StringConstant
	 *     Concat returns StringConstant
	 *     Concat.Concat_1_0 returns StringConstant
	 *     PlusMinus returns StringConstant
	 *     PlusMinus.PlusMinus_1_0 returns StringConstant
	 *     MultDiv returns StringConstant
	 *     MultDiv.MultDiv_1_0 returns StringConstant
	 *     Primitive returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveAccess().getValueSTRINGTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns TypeConstant
	 *     Boolean returns TypeConstant
	 *     Boolean.Boolean_1_0 returns TypeConstant
	 *     Equal returns TypeConstant
	 *     Equal.Equal_1_0 returns TypeConstant
	 *     Compare returns TypeConstant
	 *     Compare.Compare_1_0 returns TypeConstant
	 *     Concat returns TypeConstant
	 *     Concat.Concat_1_0 returns TypeConstant
	 *     PlusMinus returns TypeConstant
	 *     PlusMinus.PlusMinus_1_0 returns TypeConstant
	 *     MultDiv returns TypeConstant
	 *     MultDiv.MultDiv_1_0 returns TypeConstant
	 *     Primitive returns TypeConstant
	 *
	 * Constraint:
	 *     type=Type
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, TypeConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.TYPE_CONSTANT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.TYPE_CONSTANT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveAccess().getTypeTypeParserRuleCall_4_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns VarRef
	 *     Boolean returns VarRef
	 *     Boolean.Boolean_1_0 returns VarRef
	 *     Equal returns VarRef
	 *     Equal.Equal_1_0 returns VarRef
	 *     Compare returns VarRef
	 *     Compare.Compare_1_0 returns VarRef
	 *     Concat returns VarRef
	 *     Concat.Concat_1_0 returns VarRef
	 *     PlusMinus returns VarRef
	 *     PlusMinus.PlusMinus_1_0 returns VarRef
	 *     MultDiv returns VarRef
	 *     MultDiv.MultDiv_1_0 returns VarRef
	 *     Primitive returns VarRef
	 *
	 * Constraint:
	 *     ref=[CrossRef|ID]
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, VarRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.VAR_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.VAR_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveAccess().getRefCrossRefIDTerminalRuleCall_5_1_0_1(), semanticObject.eGet(DslPackage.Literals.VAR_REF__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UI23 returns UI23
	 *
	 * Constraint:
	 *     (name=ID functions+=Function* forms+=Form*)
	 * </pre>
	 */
	protected void sequence_UI23(ISerializationContext context, UI23 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
