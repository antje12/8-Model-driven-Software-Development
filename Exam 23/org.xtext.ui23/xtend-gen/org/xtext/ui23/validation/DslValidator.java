/**
 * generated by Xtext 2.29.0
 */
package org.xtext.ui23.validation;

import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.xtext.ui23.dsl.Button;
import org.xtext.ui23.dsl.Compare;
import org.xtext.ui23.dsl.Concat;
import org.xtext.ui23.dsl.DslPackage;
import org.xtext.ui23.dsl.Equal;
import org.xtext.ui23.dsl.Form;
import org.xtext.ui23.dsl.FormUse;
import org.xtext.ui23.dsl.FuncCall;
import org.xtext.ui23.dsl.Function;
import org.xtext.ui23.dsl.InputText;
import org.xtext.ui23.dsl.IntConstant;
import org.xtext.ui23.dsl.Length;
import org.xtext.ui23.dsl.MultDiv;
import org.xtext.ui23.dsl.Not;
import org.xtext.ui23.dsl.Parameter;
import org.xtext.ui23.dsl.Parenthesis;
import org.xtext.ui23.dsl.PlusMinus;
import org.xtext.ui23.dsl.StringConstant;
import org.xtext.ui23.dsl.TypeConstant;
import org.xtext.ui23.dsl.UI23;
import org.xtext.ui23.dsl.VarRef;

@SuppressWarnings("all")
public class DslValidator extends AbstractDslValidator {
  public static final String UNIQUE_NAME = "unique_name";

  public static final String SINGLE_TYPE = "single_type";

  public static final String ARGUMENT_MATCH = "argument_match";

  public static final String BOOL_TYPE = "boolean";

  public static final String STRING_TYPE = "string";

  public static final String NUMBER_TYPE = "number";

  @Check
  public void uniqueElementName(final InputText inputText) {
    final Function1<String, Boolean> _function = (String it) -> {
      String _name = inputText.getName();
      return Boolean.valueOf(Objects.equal(it, _name));
    };
    int _size = IterableExtensions.size(IterableExtensions.<String>filter(this.elementNames(inputText), _function));
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      final String error = String.format("The name must be unique");
      this.error(error, DslPackage.eINSTANCE.getCrossRef_Name(), DslValidator.UNIQUE_NAME);
    }
  }

  @Check
  public void uniqueElementName(final Button button) {
    final Function1<String, Boolean> _function = (String it) -> {
      String _name = button.getName();
      return Boolean.valueOf(Objects.equal(it, _name));
    };
    int _size = IterableExtensions.size(IterableExtensions.<String>filter(this.elementNames(button), _function));
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      final String error = String.format("The name must be unique");
      this.error(error, DslPackage.eINSTANCE.getButton_Name(), DslValidator.UNIQUE_NAME);
    }
  }

  public List<String> elementNames(final EObject element) {
    final ArrayList<String> elementNames = new ArrayList<String>();
    final UI23 root = EcoreUtil2.<UI23>getContainerOfType(element, UI23.class);
    final Function1<InputText, String> _function = (InputText it) -> {
      return it.getName();
    };
    elementNames.addAll(ListExtensions.<InputText, String>map(EcoreUtil2.<InputText>getAllContentsOfType(root, InputText.class), _function));
    final Function1<Button, String> _function_1 = (Button it) -> {
      return it.getName();
    };
    elementNames.addAll(ListExtensions.<Button, String>map(EcoreUtil2.<Button>getAllContentsOfType(root, Button.class), _function_1));
    return elementNames;
  }

  @Check
  public void singleValidationType(final InputText inputText) {
    final Function1<TypeConstant, String> _function = (TypeConstant it) -> {
      return it.getType();
    };
    int _size = IterableExtensions.<String, TypeConstant>groupBy(EcoreUtil2.<TypeConstant>getAllContentsOfType(inputText, TypeConstant.class), _function).size();
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      final String error = String.format("Only one type can be validated");
      this.error(error, DslPackage.eINSTANCE.getElement_Exp(), DslValidator.SINGLE_TYPE);
    }
  }

  @Check
  public void funcCallArguments(final FuncCall funcCall) {
    final Function function = funcCall.getRef();
    int _length = ((Object[])Conversions.unwrapArray(function.getTypes(), Object.class)).length;
    int _length_1 = ((Object[])Conversions.unwrapArray(funcCall.getExps(), Object.class)).length;
    boolean _equals = (_length == _length_1);
    boolean _not = (!_equals);
    if (_not) {
      final String error = String.format("Wrong amount of arguments");
      this.error(error, DslPackage.eINSTANCE.getFuncCall_Exps(), DslValidator.ARGUMENT_MATCH);
    }
    for (int i = 0; (i < function.getTypes().size()); i++) {
      {
        final String expectedType = function.getTypes().get(i);
        final String realType = DslValidator.getType(funcCall.getExps().get(i));
        boolean _notEquals = (!Objects.equal(expectedType, realType));
        if (_notEquals) {
          final String error_1 = String.format("Wrong type of argument");
          this.error(error_1, DslPackage.Literals.FUNC_CALL__EXPS, i);
          return;
        }
      }
    }
  }

  @Check
  public void formUseArguments(final FormUse formUse) {
    final Form form = formUse.getForm();
    int _length = ((Object[])Conversions.unwrapArray(form.getParameters(), Object.class)).length;
    int _length_1 = ((Object[])Conversions.unwrapArray(formUse.getExps(), Object.class)).length;
    boolean _equals = (_length == _length_1);
    boolean _not = (!_equals);
    if (_not) {
      final String error = String.format("Wrong amount of arguments");
      this.error(error, DslPackage.eINSTANCE.getFormUse_Exps(), DslValidator.ARGUMENT_MATCH);
    }
    for (int i = 0; (i < form.getParameters().size()); i++) {
      {
        final String expectedType = form.getParameters().get(i).getType();
        final String realType = DslValidator.getType(formUse.getExps().get(i));
        boolean _notEquals = (!Objects.equal(expectedType, realType));
        if (_notEquals) {
          final String error_1 = String.format("Wrong type of argument");
          this.error(error_1, DslPackage.Literals.FORM_USE__EXPS, i);
          return;
        }
      }
    }
  }

  protected static String _getType(final org.xtext.ui23.dsl.Boolean exp) {
    return DslValidator.BOOL_TYPE;
  }

  protected static String _getType(final Equal exp) {
    return DslValidator.BOOL_TYPE;
  }

  protected static String _getType(final Compare exp) {
    return DslValidator.BOOL_TYPE;
  }

  protected static String _getType(final Concat exp) {
    return DslValidator.STRING_TYPE;
  }

  protected static String _getType(final PlusMinus exp) {
    return DslValidator.NUMBER_TYPE;
  }

  protected static String _getType(final MultDiv exp) {
    return DslValidator.NUMBER_TYPE;
  }

  protected static String _getType(final IntConstant exp) {
    return DslValidator.NUMBER_TYPE;
  }

  protected static String _getType(final StringConstant exp) {
    return DslValidator.STRING_TYPE;
  }

  protected static String _getType(final Not exp) {
    return DslValidator.BOOL_TYPE;
  }

  protected static String _getType(final Length exp) {
    return DslValidator.NUMBER_TYPE;
  }

  protected static String _getType(final TypeConstant exp) {
    return exp.getType();
  }

  protected static String _getType(final VarRef exp) {
    return DslValidator.getType(exp.getRef());
  }

  protected static String _getType(final FuncCall exp) {
    return exp.getRef().getReturnType();
  }

  protected static String _getType(final Parenthesis exp) {
    return DslValidator.getType(exp.getExp());
  }

  protected static String _getType(final InputText exp) {
    return DslValidator.getType(exp.getExp());
  }

  protected static String _getType(final Parameter exp) {
    return exp.getType();
  }

  public static String getType(final EObject exp) {
    if (exp instanceof InputText) {
      return _getType((InputText)exp);
    } else if (exp instanceof org.xtext.ui23.dsl.Boolean) {
      return _getType((org.xtext.ui23.dsl.Boolean)exp);
    } else if (exp instanceof Compare) {
      return _getType((Compare)exp);
    } else if (exp instanceof Concat) {
      return _getType((Concat)exp);
    } else if (exp instanceof Equal) {
      return _getType((Equal)exp);
    } else if (exp instanceof FuncCall) {
      return _getType((FuncCall)exp);
    } else if (exp instanceof IntConstant) {
      return _getType((IntConstant)exp);
    } else if (exp instanceof Length) {
      return _getType((Length)exp);
    } else if (exp instanceof MultDiv) {
      return _getType((MultDiv)exp);
    } else if (exp instanceof Not) {
      return _getType((Not)exp);
    } else if (exp instanceof Parameter) {
      return _getType((Parameter)exp);
    } else if (exp instanceof Parenthesis) {
      return _getType((Parenthesis)exp);
    } else if (exp instanceof PlusMinus) {
      return _getType((PlusMinus)exp);
    } else if (exp instanceof StringConstant) {
      return _getType((StringConstant)exp);
    } else if (exp instanceof TypeConstant) {
      return _getType((TypeConstant)exp);
    } else if (exp instanceof VarRef) {
      return _getType((VarRef)exp);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(exp).toString());
    }
  }
}
