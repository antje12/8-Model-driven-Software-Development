/*
 * generated by Xtext 2.29.0
 */
package org.xtext.ui23.validation

import org.eclipse.xtext.validation.Check
import org.xtext.ui23.dsl.InputText
import org.xtext.ui23.dsl.Button
import org.xtext.ui23.dsl.Parameter
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.EcoreUtil2
import org.xtext.ui23.dsl.UI23
import org.xtext.ui23.dsl.DslPackage
import java.util.ArrayList
import org.xtext.ui23.dsl.TypeConstant
import org.xtext.ui23.dsl.FuncCall
import org.xtext.ui23.dsl.DslPackage.Literals
import org.xtext.ui23.dsl.Boolean
import org.xtext.ui23.dsl.Equal
import org.xtext.ui23.dsl.Compare
import org.xtext.ui23.dsl.Concat
import org.xtext.ui23.dsl.PlusMinus
import org.xtext.ui23.dsl.MultDiv
import org.xtext.ui23.dsl.IntConstant
import org.xtext.ui23.dsl.StringConstant
import org.xtext.ui23.dsl.Not
import org.xtext.ui23.dsl.Length
import org.xtext.ui23.dsl.VarRef
import org.xtext.ui23.dsl.Parenthesis
import org.xtext.ui23.dsl.FormUse

class DslValidator extends AbstractDslValidator {

	public static final String UNIQUE_NAME = 'unique_name'
	public static final String SINGLE_TYPE = 'single_type'
	public static final String ARGUMENT_MATCH = 'argument_match'

	public static final String BOOL_TYPE = "boolean"
	public static final String STRING_TYPE = "string"
	public static final String NUMBER_TYPE = "number"

	// Duplicated names of elements. 
	// For example, if you have the same name for an input and a button, 
	// then the program would not be able to know which one the developer is referring to.
	@Check
	def void uniqueElementName(InputText inputText) {
		if (elementNames(inputText).filter[it == inputText.name].size > 1) {
			val error = String.format("The name must be unique")
			error(error, DslPackage.eINSTANCE.crossRef_Name, UNIQUE_NAME)
		}
	}

	@Check
	def void uniqueElementName(Button button) {
		if (elementNames(button).filter[it == button.name].size > 1) {
			val error = String.format("The name must be unique")
			error(error, DslPackage.eINSTANCE.button_Name, UNIQUE_NAME)
		}
	}

	def List<String> elementNames(EObject element) {
		val elementNames = new ArrayList<String>()
		val root = EcoreUtil2.getContainerOfType(element, UI23)
		elementNames.addAll(EcoreUtil2.getAllContentsOfType(root, InputText).map[it.name])
		elementNames.addAll(EcoreUtil2.getAllContentsOfType(root, Button).map[it.name])
		return elementNames
	}

	// Only use one type keyword in a question input validation expression. 
	// It is illegal to use number > 0 && text == "yes" as input validation.
	@Check
	def void singleValidationType(InputText inputText) {
		if (EcoreUtil2.getAllContentsOfType(inputText, TypeConstant).groupBy[it.type].size > 1) {
			val error = String.format("Only one type can be validated")
			error(error, DslPackage.eINSTANCE.element_Exp, SINGLE_TYPE)
		}
	}

	// The function and form call arguments should match their parameters definition. 
	// The same amount of arguments and correspondent type.
	@Check
	def void funcCallArguments(FuncCall funcCall) {
		val function = funcCall.ref
		if (!(function.types.length == funcCall.exps.length)) {
			val error = String.format("Wrong amount of arguments")
			error(error, DslPackage.eINSTANCE.funcCall_Exps, ARGUMENT_MATCH)
		}
		for (var i = 0; i < function.types.size; i++) {
			val expectedType = function.types.get(i)
			val realType = funcCall.exps.get(i).getType
			if (expectedType != realType) {
				val error = String.format("Wrong type of argument")
				error(error, Literals.FUNC_CALL__EXPS, i)
				return
			}
		}
	}

	@Check
	def void formUseArguments(FormUse formUse) {
		val form = formUse.form
		if (!(form.parameters.length == formUse.exps.length)) {
			val error = String.format("Wrong amount of arguments")
			error(error, DslPackage.eINSTANCE.formUse_Exps, ARGUMENT_MATCH)
		}
		for (var i = 0; i < form.parameters.size; i++) {
			val expectedType = form.parameters.get(i).type
			val realType = formUse.exps.get(i).getType
			if (expectedType != realType) {
				val error = String.format("Wrong type of argument")
				error(error, Literals.FORM_USE__EXPS, i)
				return
			}
		}
	}

	def static dispatch String getType(Boolean exp) { BOOL_TYPE }
	def static dispatch String getType(Equal exp) { BOOL_TYPE }
	def static dispatch String getType(Compare exp) { BOOL_TYPE }
	def static dispatch String getType(Concat exp) { STRING_TYPE }
	def static dispatch String getType(PlusMinus exp) { NUMBER_TYPE }
	def static dispatch String getType(MultDiv exp) { NUMBER_TYPE }
	def static dispatch String getType(IntConstant exp) { NUMBER_TYPE }
	def static dispatch String getType(StringConstant exp) { STRING_TYPE }
	def static dispatch String getType(Not exp) { BOOL_TYPE }
	def static dispatch String getType(Length exp) { NUMBER_TYPE }
	def static dispatch String getType(TypeConstant exp) { exp.type }
	def static dispatch String getType(VarRef exp) { exp.ref.getType }
	def static dispatch String getType(FuncCall exp) { exp.ref.returnType }
	def static dispatch String getType(Parenthesis exp) { exp.exp.getType }
	def static dispatch String getType(InputText exp) { exp.exp.getType }
	def static dispatch String getType(Parameter exp) { exp.type }
}
